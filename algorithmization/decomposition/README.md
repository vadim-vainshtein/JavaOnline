Декомпозиция с использованием методов
=================

	package algorithmization.decomposition;

Задачи располагаются каждая в своём каталоге algorithmization/decomposition/task*

В решениях используются методы из специально созданного класса 

	algorithmization.Util

Задача 1
-----------------

	algorithmization.decomposition.task01.Main

*Найти НОД и НОК двух натуральных чисел*

Используются методы GCD() и LCM() из класса

	algorithmization.Util

Задача 2
-----------------
	
	algorithmization.decomposition.task02.Main
	
*Найти НОД четырёх натуральных чисел*
	
Легко показать, что НОД(a, b, c, d) = НОД (НОД(a, b), НОД(c, d)). Соответствующий метод описан в классе Main
	
Задача 3
-----------------

	algorithmization.decomposition.task03.Main

*Найти сумму правильного шестиугольника со стороной a через сумму площадей треугольников*

Методы triangleArea() и hexagonArea() для вычисления площадей треугольника и шестиугольника находятся в классе
	
	algorithmization.Util;

Задача 4
-----------------

	algorithmization.decomposition.task04.Main

*На плоскости заданы n точек. Наптсать метод, определяющий, между какими из пар точек максимальное расстояние. Координаты точек занести в массив*

Создадим класс Point, хранящий координаты точки, и имеющий метод для определения расстояния между точками. В нём же определим статический метод для нахождения в массиве индексов точек, имеющих максимальное расстояние между собой

	algorithmization.decomposition.task04.Point; // класс "точка"
	Point.distanceTo(Point p) // расстояние от этой до другой точки
	int[] Point.mostDistant(Point[]) // нахождение индексов наиболее удалённых друг от друга точек

В классе Main - проверка работоспособности вышеописанных методов

Задача 5
-----------------

	algorithmization.decomposition.task05.Main

*В массиве найти число меньше максимального, но больше всех остальных*

Можно сначала найти максимальный элемент, а затем найти следующий за ним,
однако более оптимальным вариантом выглядит поиск сразу и наибольшего элемента,
и следующего за ним.