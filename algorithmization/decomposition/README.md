Декомпозиция с использованием методов
=================

	package algorithmization.decomposition;

Задачи располагаются каждая в своём каталоге algorithmization/decomposition/task*

В решениях используются методы из специально созданного класса 

	algorithmization.Util

Задача 1
-----------------

	algorithmization.decomposition.task01.Main

*Найти НОД и НОК двух натуральных чисел*

Используются методы GCD() и LCM() из класса

	algorithmization.Util

Задача 2
-----------------
	
	algorithmization.decomposition.task02.Main
	
*Найти НОД четырёх натуральных чисел*
	
Легко показать, что НОД(a, b, c, d) = НОД (НОД(a, b), НОД(c, d)). Соответствующий метод описан в классе Main
	
Задача 3
-----------------

	algorithmization.decomposition.task03.Main

*Найти сумму правильного шестиугольника со стороной a через сумму площадей треугольников*

Методы triangleArea() и hexagonArea() для вычисления площадей треугольника и шестиугольника находятся в классе
	
	algorithmization.Util;

Задача 4
-----------------

	algorithmization.decomposition.task04.Main

*На плоскости заданы n точек. Наптсать метод, определяющий, между какими из пар точек максимальное расстояние. Координаты точек занести в массив*

Создадим класс Point, хранящий координаты точки, и имеющий метод для определения расстояния между точками. В нём же определим статический метод для нахождения в массиве индексов точек, имеющих максимальное расстояние между собой

	algorithmization.decomposition.task04.Point; // класс "точка"
	Point.distanceTo(Point p) // расстояние от этой до другой точки
	int[] Point.mostDistant(Point[]) // нахождение индексов наиболее удалённых друг от друга точек

В классе Main - проверка работоспособности вышеописанных методов

Задача 5
-----------------

	algorithmization.decomposition.task05.Main

*В массиве найти число меньше максимального, но больше всех остальных*

Можно сначала найти максимальный элемент, а затем найти следующий за ним,
однако более оптимальным вариантом выглядит поиск сразу и наибольшего элемента,
и следующего за ним.

Задача 6
-----------------

	algorithmization.decomposition.task06.Main

*Определить, являются ли три числа взаимно простыми*

Используется метод

	algorithmization.Util.areCoprime(int[])

На входе - массив натуральных чисел. Метод возвращает true, если они все взаимно простые, и false - если есть два числа с НОД > 1
Метод areCoprime, в свою очередь, использует метод GCD. Это не вполне оптимально, так как поиск делителя можно останавливать,
как только найден делитель > 1.

Задача 7
-----------------

	algorithmization.decomposition.task07.Main

*Вычислить сумму факториалов всех нечётных чисел от 1 до 9*

Используем методы для получения подмножества класса вычетов по модулю, вычисления факториала, суммирования элементов массива:

	algorithmization.Util.residueClass();
	algorithmization.Util.factorial();
	algorithmization.Util.sum();

Задача 8
-----------------
	
	algorithmization.decomposition.task08.Main

*Составить метод для вычисления суммы нескольких последовательно расположенных элементов в массиве*

Перегрузим метод

	algorithmization.Util.sum();

введя в качестве дополнительных параметров элемент, с которого начинается суммирование, и количество элементов, которые необходимо просуммировать.

Задача 9
-----------------

	algorithmization.decomposition.task09.Main

*Даны длины сторон четырёхугольника - x, y, z, t. Написать метод(ы) вычисления его площади, если угол между x и y - прямой*

