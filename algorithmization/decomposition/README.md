Декомпозиция с использованием методов
=================

	package algorithmization.decomposition;

Задачи располагаются каждая в своём каталоге algorithmization/decomposition/task*

В решениях используются методы из специально созданного класса 

	algorithmization.Util

Задача 1
-----------------

	algorithmization.decomposition.task01.Main

*Найти НОД и НОК двух натуральных чисел*

Используются методы GCD() и LCM() из класса

	algorithmization.Util

Задача 2
-----------------
	
	algorithmization.decomposition.task02.Main
	
*Найти НОД четырёх натуральных чисел*
	
Легко показать, что НОД(a, b, c, d) = НОД (НОД(a, b), НОД(c, d)). Соответствующий метод описан в классе Main
	
Задача 3
-----------------

	algorithmization.decomposition.task03.Main

*Найти сумму правильного шестиугольника со стороной a через сумму площадей треугольников*

Методы triangleArea() и hexagonArea() для вычисления площадей треугольника и шестиугольника находятся в классе
	
	algorithmization.Util;

Задача 4
-----------------

	algorithmization.decomposition.task04.Main

*На плоскости заданы n точек. Наптсать метод, определяющий, между какими из пар точек максимальное расстояние. Координаты точек занести в массив*

Создадим класс Point, хранящий координаты точки, и имеющий метод для определения расстояния между точками. В нём же определим статический метод для нахождения в массиве индексов точек, имеющих максимальное расстояние между собой

	algorithmization.decomposition.task04.Point; // класс "точка"
	Point.distanceTo(Point p) // расстояние от этой до другой точки
	int[] Point.mostDistant(Point[]) // нахождение индексов наиболее удалённых друг от друга точек

В классе Main - проверка работоспособности вышеописанных методов

Задача 5
-----------------

	algorithmization.decomposition.task05.Main

*В массиве найти число меньше максимального, но больше всех остальных*

Можно сначала найти максимальный элемент, а затем найти следующий за ним,
однако более оптимальным вариантом выглядит поиск сразу и наибольшего элемента,
и следующего за ним.

Задача 6
-----------------

	algorithmization.decomposition.task06.Main

*Определить, являются ли три числа взаимно простыми*

Используется метод

	algorithmization.Util.areCoprime(int[])

На входе - массив натуральных чисел. Метод возвращает true, если они все взаимно простые, и false - если есть два числа с НОД > 1
Метод areCoprime, в свою очередь, использует метод GCD. Это не вполне оптимально, так как поиск делителя можно останавливать,
как только найден делитель > 1.

Задача 7
-----------------

	algorithmization.decomposition.task07.Main

*Вычислить сумму факториалов всех нечётных чисел от 1 до 9*

Используем методы для получения подмножества класса вычетов по модулю, вычисления факториала, суммирования элементов массива:

	algorithmization.Util.residueClass();
	algorithmization.Util.factorial();
	algorithmization.Util.sum();

Задача 8
-----------------
	
	algorithmization.decomposition.task08.Main

*Составить метод для вычисления суммы нескольких последовательно расположенных элементов в массиве*

Перегрузим метод

	algorithmization.Util.sum();

введя в качестве дополнительных параметров элемент, с которого начинается суммирование, и количество элементов, которые необходимо просуммировать.

Задача 9
-----------------

	algorithmization.decomposition.task09.Main

*Даны длины сторон четырёхугольника - x, y, z, t. Написать метод(ы) вычисления его площади, если угол между x и y - прямой*

В классе Main реализован метод quadrilateralArea() для вычисления площади этой фигуры, использующий метод

	algorithmization.Util.triangleAreaBySides();

для вычисления площади треуголбника по трём сторонам.

Задача 10
-----------------

	algorithmization.decomposition.task10.Main

*Дано натуральное число N. Написать метод, составляющий массив из цифр этого числа*

Реализован метод

	algorithmization.Util.getDigits()

использует метод

	algorithmization.Util.numberOfDigits()
	
для подсчёта количества разрядов


Задача 11
-----------------

	algorithmization.decomposition.task11.Main

*Написать метод, определяющий, в каком из даных чисел больше разрядов*

Используется метод

	algorithmization.Util.hasMoreDigits(),

использующий в свою очередь метод numberOfDigits()

Задача 12
-----------------

	algorithmization.decomposition.task12.Main

*Написать метод(ы) формирования массива, элементами которого являются числа, сумма цифр которых равна k и которые не больше n*

Метод реализован в классе Main. Последовательно перебираем все числа от 0 до n, выбирая те, сумма цифр которых равна k. Алгоритм явно неоптимальный, однако ничего лучшего реализовать мне пока не удалось.

В алгоритме используются методы класса Util getDigits() и sum() для проверки суммы цифр числа.

Задача 13
-----------------

	algorithmization.decomposition.task13.Main

* Найти и напечатать все пары "близнецов" в интервале [n, 2n], где n > 2. Близнецы - пары простых чисел, отличающихся на 2*

Для хранения и форматирования пары чисел используется класс

	algorithmization.decomposition.task13.Pair

Использованы методы для получения ряда простых чисел, нахождения среди них близнецов и для вывода их на экран:

	algorithmization.Util.primeNumbers();
	findTwins();
	printPairs();

